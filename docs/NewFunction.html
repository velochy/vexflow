<!DOCTYPE html>
<html>
<head>
  <title>The VexFlow Tutorial</title>

  <!-- VexFlow Compiled Source -->
  <script src="../support/vexflow-min.js"></script>

  <!-- Support Sources -->
  <script src="../support/jquery.js"></script>
  <script src="../support/raphael.js"></script>

  <style type="text/css">
    canvas {
      background: #eed;
      padding: 10px;
      border: 10px solid #ddc;
    }

    div.egcode {
      font-family: Courier;
      font-size: 14px;
    }
  </style>

  <script>
    /* Take raw javascript code, and return moderately useful HTML */
    function prettify_code(code) {
      var lines = code.split(/\r\n|\n|\r/);
      var new_lines = [];
      for (var j = 0; j < lines.length; ++j) {
        code = lines[j];
        code = code.replace(/\s/g, "&nbsp;");
        code = code.replace(/>/g, "&gt;");
        code = code.replace(/</g, "&lt;");
        new_lines.push(code);
      }

      pretty_code = "<div class='egcode'>" + new_lines.join("<br/>") + "</div>";
      return pretty_code;
    }

    /*
       Find all the javascript examples and copy their source code
       into the associated <code> blocks.
    */
    $(function() {
      $("div.description").each(function(index, sel) {
        codes = $(sel).find("code.example");
        codes.each(function(i, s) {
          var example = $(s).attr("example");
          var code = $($(sel).find(
            "div.example." + example + " script")[0]).html();
          $(s).html(prettify_code(code));
         })
      })
    })
  </script>
</head>

<body>
    <h2>Playing around</h2>
    <div class="description two">
      <div class="example a" example="a">
        <canvas width=525 height=120></canvas>
        <p/>
        <script>
  var canvas = $("div.two div.a canvas")[0];
  //var paper = Raphael(canvas,100,100);
  //var renderer = new Vex.Flow.Renderer(paper,
  //  Vex.Flow.Renderer.Backends.RAPHAEL);
  var renderer = new Vex.Flow.Renderer(canvas,
    Vex.Flow.Renderer.Backends.CANVAS);
  var ctx = renderer.getContext();
  

  function drawNotes(durations,beat_boundaries,bar_duration,x,y,width,ctx) {

  var TICKS_PER_PULSE = 8*3*5;  // Because float arithmetic is a pain in the behind, turn the durations into integers
  var durInTicks = []; durations.forEach(function(d) { durInTicks.push(Math.round(d*TICKS_PER_PULSE)); });
  var barInTicks = Math.round(bar_duration*TICKS_PER_PULSE);
  var boundsInTicks = [];  beat_boundaries.forEach(function(d) { boundsInTicks.push(Math.round(d*TICKS_PER_PULSE)); });


  note_names = ["w","h","q","8","16","32"];
  function getSym(x) {
    var i=0;
    for (var d=4*TICKS_PER_PULSE;d>x;d/=2) i++;

    var n = note_names[i];  var ds = d;
    while ( x>=ds+0.5*d ) {
        d*=0.5; ds+=d; n+="d";
    }

    return { name: n, duration: ds };
  }

  function createNote(name) {
    var note = new Vex.Flow.StaveNote({ keys: ["f/4"], duration: name });
    var ndots = name.match(/d/g);
    ndots=(ndots==null?0:ndots.length);
    for(var i=0; i<ndots; i++) note.addDotToAll();
    return note;
  }

  function createTie(n1,n2) {
    return new Vex.Flow.StaveTie({
            first_note: n1,
            last_note: n2,
            first_indices: 0,
            last_indices: 0,
        });
  }

  function createBeam(vfnotes) {
    return new Vex.Flow.Beam(vfnotes,true);
  }

  var nextBound = boundsInTicks[0];
  var nextBoundIndex = 0;
 
  var sum = 0; // Duration up to the current point
  var vfnotes = []; // The notes to be rendered
  var ties = []; // Note ties
  var beams =[]; // Note beams 
  var cbeam = []; // List of notes under the current beam
  var barBeginners = []; // Notes at the beginning of bars

  // Iterate over all durations
  for(var i=0;i<durInTicks.length;i++) { 
      var clen = durInTicks[i];
      var cties = [];
      
      // Choose the notes that would compose the duration
      while (clen>0) {

          // Respect bar and (to lesser degree) beat boundaries
          var sym = getSym(Math.min(clen, // Never take a note longer than required to complete the current duration
                    sum<nextBound? // Already mid-beat?
                        nextBound-sum: // Yes - respect the beat boundary
                        barInTicks-(sum%barInTicks) // No - only respect bar boundary
                ));

          cties.push(vfnotes.length);
          vfnotes.push(createNote(sym["name"]));
    
          // If first note in the bar, remmember it so the barline could be drawn later
          if (sum>0 && sum%barInTicks == 0) { barBeginners.push(vfnotes[vfnotes.length-1]); }

          sum += sym["duration"];
          clen -= sym["duration"];
 
          // Is a beam required?
          if (sym["duration"]<TICKS_PER_PULSE) {
              cbeam.push(vfnotes[vfnotes.length-1]);
          }   

          // Did we cross a beat boundary (in which case a beam should end here)
          if (cbeam.length>0 && (sum==nextBound || sym["duration"]>=TICKS_PER_PULSE)) {
            if (cbeam.length>1) beams.push(createBeam(cbeam));
            cbeam=[];
          }

          // If we crossed an emphasis boundary, increment the emphasis counter
          if (sum >= nextBound) {
            nextBoundIndex = (nextBoundIndex+1)%boundsInTicks.length;
            nextBound += boundsInTicks[nextBoundIndex];
          }
      }
      // If we decomposed the duration to more than one note, tie them together
      if (cties.length>1) 
          for( var j=1; j<cties.length; j++) {
              ties.push(createTie(vfnotes[cties[j-1]],vfnotes[cties[j]]));
          }
  } 

  var stave = new Vex.Flow.Stave(x, y, width,{num_lines:0,space_below_staff_ln:0,space_above_staff_ln:1,bottom_text_position:0,top_text_position:0});
  stave.setContext(ctx);

  // Create a voice in 4/4
  var voice = new Vex.Flow.Voice({
    num_beats: Math.round(durations.reduce(function(prev,cur) { return prev+cur; })),
    beat_value: 4,
    resolution: Vex.Flow.RESOLUTION
  });

  // Add notes to voice
  voice.addTickables(vfnotes);


  // Format and justify the notes to 500 pixels
  var formatter = new Vex.Flow.Formatter().
    joinVoices([voice]).formatToStave([voice],stave);


  // Render voice
  voice.draw(ctx, stave);
  
  // Draw beams
  beams.forEach(function(beam){
    beam.setContext(ctx).draw();
  });

  // Draw ties
  ties.forEach(function(tie){
    tie.setContext(ctx).draw();
  });
 

  // Draw bar lines
  barBeginners.forEach(function(note) {  
      ctx.fillRect(Math.round(note.getAbsoluteX())-3,y+5,2,45);
  });
  ctx.fillRect(x+width,y+5,2,45);


  var note_positions=[];
  voice.tickables.forEach(function(t) { note_positions.push(Math.round(t.getAbsoluteX())); });

  return note_positions;

  }

  var durations = [1,0.5,0.5,0.5,0.5,0.5,1,0.5,0.5,0.5,0.5,0.5,0.5,0.5];
  alert(drawNotes(durations,[2],4,0,0,500,ctx));
  var durations = [0.5,0.25,0.25,0.5,0.5,0.25,0.25,0.5,0.5,0.25,0.25,0.5,0.25,0.25,0.5,0.5,0.25,0.25,0.5,0.5,0.25,0.25];
  drawNotes(durations,[1.5,1.5,1],4,0,60,500,ctx);
  
       </script></p>
      </div>
      </div>
</body>

</html>
